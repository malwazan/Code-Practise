type: edu
files:
- name: closest_points.py
  visible: true
  placeholders:
  - offset: 600
    length: 9
    placeholder_text: type here
    initial_state:
      length: 9
      offset: 600
    initialized_from_dependency: false
    selected: false
    status: Unchecked
  text: |
    # python3
    from collections import namedtuple
    from itertools import combinations
    from math import sqrt


    Point = namedtuple('Point', 'x y')


    def distance_squared(first_point, second_point):
        return (first_point.x - second_point.x) ** 2 + (first_point.y - second_point.y) ** 2


    def minimum_distance_squared_naive(points):
        min_distance_squared = float("inf")

        for p, q in combinations(points, 2):
            min_distance_squared = min(min_distance_squared,
                                       distance_squared(p, q))

        return min_distance_squared


    def minimum_distance_squared(points):
        type here


    if __name__ == '__main__':
        input_n = int(input())
        input_points = []
        for _ in range(input_n):
            x, y = map(int, input().split())
            input_point = Point(x, y)
            input_points.append(input_point)

        print("{0:.9f}".format(sqrt(minimum_distance_squared_naive(input_points))))
  learner_created: false
- name: closest_points_unit_tests.py
  visible: true
  placeholders:
  - offset: 278
    length: 9
    placeholder_text: type here
    initial_state:
      length: 9
      offset: 278
    initialized_from_dependency: false
    selected: false
    status: Unchecked
  - offset: 1059
    length: 9
    placeholder_text: type here
    initial_state:
      length: 9
      offset: 1059
    initialized_from_dependency: false
    selected: false
    status: Unchecked
  text: |
    import unittest
    from closest_points import minimum_distance_squared, minimum_distance_squared_naive, Point
    from random import randint


    class ClosestPoints(unittest.TestCase):
        def test_small(self):
            for points in (
                [Point(1, 0), Point(1, 1)],
                type here
            ):
                self.assertAlmostEqual(minimum_distance_squared(points),
                                       minimum_distance_squared_naive(points),
                                       delta=1e-03)

        def test_random(self):
            for n in [2, 5, 10, 100]:
                for max_value in [1, 2, 3, 1000]:
                    points = []
                    for _ in range(n):
                        x = randint(-max_value, max_value)
                        y = randint(-max_value, max_value)
                        points.append(Point(x, y))

                    self.assertAlmostEqual(minimum_distance_squared(points),
                                           minimum_distance_squared_naive(points),
                                           delta=1e-03)

        def test_large(self):
            type here


    if __name__ == '__main__':
        unittest.main()
  learner_created: false
- name: logo.png
  visible: false
  text: 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
  learner_created: false
- name: tests.py
  visible: false
  text: |
    from test_helper import run_common_tests, failed, passed, check_tests_pass
    from closest_points import minimum_distance_squared, minimum_distance_squared_naive, Point
    from math import fabs
    from random import randint


    if __name__ == '__main__':
        run_common_tests()
        check_tests_pass("closest_points_unit_tests.py")

        all_tests_passed = True

        for points in (
            [Point(-10 ** 9, - 10 ** 9), Point(10 ** 9, 10 ** 9)],
            [Point(i, i + 1) for i in range(100)],
            [Point(randint(1, 10), randint(1, 10)) for _ in range(5)],
            [Point(randint(1, 10), randint(1, 10)) for _ in range(500)]
        ):
            if fabs(minimum_distance_squared(points) - minimum_distance_squared_naive(points)) > 1e-03:
                all_tests_passed = False
                failed("Wrong answer for points={}".format(points))
                break

        if all_tests_passed:
            passed()
  learner_created: false
feedback_link: https://www.coursera.org/learn/algorithmic-toolbox/programming/w9YDz/programming-assignment-3-divide-and-conquer/discussions
status: Unchecked
record: -1
